##JSON-to-CSV Conversion Overview##

Below are some frequently asked questions about the JSON-to-CSV conversion process. If 
you are interested in some technical (philosophical even) background on the JSON and CSV formats, and the conversion process between the two, see [HERE - not finished yet].  

#### I need the JSON data converted to CSV. What do you need from me? ####
We need a [tweet template] (./JSON-to-CSV_overview.md#tweet-templates) which identifies all the tweet attributes that you are interested in. The conversion process uses this template and creates a CSV file with a column for every attribute in the template. The conversion process represents an opportunity to ‘tune’ what you want to export. For example, the standard Twitter metadata includes the numeric character position of hashtags in a tweet message. You may decide that you do not need this information, and therefore can omit those details from your tweet template.

#### How are CSV column names determined?####

CSV column names are generated by referencing the JSON object names and using dot notation to indicate levels and arrays of attributes. For example, here are some JSON attributes:   

```
{
  "id": "tag:search.twitter.com,2005:418130988250570752",
  "actor": {
    "id": "id:twitter.com:17200003"
  },
 "twitter_entities": {
      "hashtags": [
        {
          "text": "HappyNewYear",
        }
      ]
  }
}
```

Using dot notation, these attributes would be represented with the following header:

```
id, actor.id, twitter_entities.hashtags[0].text
```

#### What if I want special names for certain columns?####
With dot notation and the many levels of JSON attributes the auto-generated names can become quite long.  Therefore you may want to override these defaults with shortened versions. The conversion process already has some ‘re-mappings’ built-in, and others can be added when wanted.  Here are some examples:

```
twitter_entities.hashtags.0.text               --> hashtags
twitter_entities.urls.0.expanded_url           --> twitter_expanded_urls
twitter_entities.user_mentions.0.screen_name   --> user_mention_screen_names
gnip.matching_rules.0.value                    --> rule_values
```

See [this] section for more information.


#### Is there any special parsing of JSON values?####
Yes, Tweet and Actor IDs are handled specially. For these IDs, the string component is stripped off and only the numeric part is retained:

```
 id, actor.id
418130988250570752,17200003
```


#### How are arrays of metadata handled? ####

Twitter metadata include many attributes that have a variable length list of values. Examples include hashtags, user mentions, and URLs. These example metadata are stored in a JSON object named ‘twitter_entities’ and each attribute is an array of length zero or more.  Arrays in CSV are stored with double-quotes around a comma-delimited list of values. So these arrays can be thought of as a list within another list.  

Using the hashtag example, multiple hashtags would be inserted into a single column with the ‘hashtags’ column header (relying on the built-in header override discussed above):

```
id,actor.id,hashtags
418130988250570752,17200003,"HashTag1,HashTag2"
```

#### How long will the conversion process take?####
It depends on how many files are being processed, how many tweets are being converted, and how many attributes are included in the template tweet. If there are 10 million tweets, and 200 tweet attributes in the template, there are 2 billion attributes to process.

Using a standard template tweet approximately 3 million tweets can be processed per hour. Large datasets can take hours to process. 


###Tweet Templates###

A Tweet Template is an example tweet payload in JSON that contains all the fields you want to export to the CSV files. Social activities, such as tweets, are dynamic in nature and the payloads from one tweet to another are sure to be different. One could be a geo-tagged tweet with several hashtags and mentions, while the next one is a retweet with an URL.  

This example tweet is referred to as the conversion ‘tweet template.’ The conversion process loads this template and then tours each of your historical tweets and exports all metadata that is specified in the template. Here is a short example template that would export the bare minimum of metadata:

```
{
  "id": "tag:search.twitter.com,2005:418130988250570752",
  "actor": {
    "id": "id:twitter.com:17200003",
    "preferredUsername": "jimmoffitt",
  },
  "verb": "post",
  "postedTime": "2013-12-31T21:26:10.000Z",
  "body": "Example tweet #HashTag1 #HashTag2"
   "twitter_entities": {
    "hashtags": [
      {"text": "HashTag1"},
      {"text": "HashTag2"}
    ]
}
```

This would be represented in a CSV file as:

```
id,actor.id,preferredUsername,verb,postedTime,body,hashtags
418130988250570752,17200003,jimmoffitt,post,2013-12-31T21:26:10.000Z,Example tweet #HashTag1 #HashTag2,"HashTag1,HashTag2"
```

A couple things to note about this JSON to CSV conversion:

+ Tweet and User IDs have been stripped down to just the numeric content.
+ Dot notation is used to preserve hierarchy when needed. In this case it was used to handle the repeated use of ‘id’. 
+ Dot notation names can be overridden (such as hashtags in this example).
+ Arrays are stored as comma-separated values inside double quotes.


###Example Tweet Templates###

It can be difficult and time-consuming to find just the perfect tweet ‘in the wild’, an actual tweet that encapsulates all metadata you care about. So you may need to ‘hand build’ your own template tweet. The means assembling an JSON object by picking and choosing the fields you want and copying them into a JSON file. When doing this, keep the following details in mind:

+ Tweet template JSON must be valid for the conversion code to work. If this code can not parse the template JSON then it will exit.
+ Order of objects does not absolutely matter.  You could have the actor object below the twitter entities object. However, the order will affect the order of the CSV columns in the output.
+ Hierarchy matters. If you skip or add a level in the template, that ‘pattern’ will not be found in the processed tweets. ``` gnip.matching_rules.0.value != gnip.matching_rules.value ``` 
+ Metadata values do not have to be internally consistent since the values of the JSON name/value pairs does not matter. All that matters are the JSON names. With the template tweet examples below you will see inconsistencies. For example the geographic metadata can be inconsistent with an actor location in one place and the Gnip Profile Geo in another. 

We have pre-built several examples:
+ ‘Small’ tweet: [HERE] (https://github.com/jimmoffitt/pt-dm/blob/master/schema/tweet_small.json)
Just select basics.
+ ‘Everything’ retweet: [HERE] (https://github.com/jimmoffitt/pt-dm/blob/master/schema/tweet_everything.json)  
     + Complete tweet and retweet 
     + All twitter entities and all attributes (like hashtag indices). 
     + Twitter geo.
     + All Gnip enrichments. 
+ ‘Standard’ tweet: [HERE] (https://github.com/jimmoffitt/pt-dm/blob/master/schema/tweet_standard.json) 
     + No Twitter geo.
     + All twitter entities with select attributes (i.e., no hashtag indices). 
     + Retweets are indicated by verb, original tweet id, and author name/id
     + Standard Gnip enrichments (matching rules, urls, language).
+ ‘Standard Geo‘ tweet: [HERE] (https://github.com/jimmoffitt/pt-dm/blob/master/schema/tweet_standard_geo.json) 
     + Same as ‘Standard’ with Twitter geo.
+ ‘Profile Geo’ tweet: [HERE] (https://github.com/jimmoffitt/pt-dm/blob/master/schema/tweet_profile_geo.json) 
     + Same as ‘Standard Geo’ with Profile Geo enrichment.
+ ‘All gnip enrichments’ tweet: [HERE] (https://github.com/jimmoffitt/pt-dm/blob/master/schema/tweet_all_enrichments.json) 
     + Same as ‘Profile Geo’ with Klout Topics.



