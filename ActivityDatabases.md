##Storing Social Media Data in Relational Databases

###Introduction

Many consumers of social media data store it in a relational database such as MySQL. 

There are several key details to ponder as you design your database schema.

* One is deciding what information to store and what, if any, to ignore/drop.
* One is handling metadata that has a variable amount of members/items. Examples include hashtags, user mentions and URLs.
* Do you need to track updates to attributes such as a user's profile location and followers count?
* Do you need to store data from multiple publishers?
 

In this article we'll discuss some fundamental decisions that need to be made, various options when designing your database schema, and provide some example schemas for getting started.

###Getting started.

New to relational database schema design? Here are some resources:
At the highest level, database schemas consist of tables that are made up of one of more rows.  
Table rows are made up of one or more fields, and these fields describe the table design.
Database schemas also involve details such as primary keys and indexes. Primary keys are made up of individual or groups of fields, and provide a mechanism to enforce uniqueness of your table contents. (example here with id = 1, adding another id = 1 will throw an error).

Indexes are helpers for searching and selecting data.  When you define an index you are asking your database engine to essentially pre-sort your data, making it faster to search. Indexes come with overhead (storing sort data) and will make your database footprint larger) so should be considered carefully and carefully crafted based on the types of queries database users are making). The following discussion will focus mainly on suggested options for specifying tables and fields, and less on recommendations for defining indexes.
 
The examples below are based on storing Twitter data in a database. If you are working with data from another social network these examples will still illustrate the type of design considerations and potential techniques for storing your data in a logical and efficient way, based on your particular use-case.

<embed a sample tweet>
    This tweet from @snowman comes with a lot of metadata #whatToStore #database 
</embed>

###What Metadata do you need to store?

When storing activity data in a database, you are essentially passing the data through a transform where you cherry-pick the data you care about. Inserting social media data into a database provides an opportunity to filter the incoming data, explicitly storing the data you want to keep, and ignoring the data you do not want. 

Every tweet arrives with a large set of supporting metadata. This set can contain well over 150 attributes that provide information about the user that posted the tweet, any available geographic information, and other information such as lists of hashtags and user mentions included in the tweet message. The entire JSON associated with the above tweet is [HERE]. For a look of all the potential metadata that can be provided see [HERE](https://github.com/jimmoffitt/pt-dm/blob/master/schema/tweet_everything.json)

Given your particular use-case you may only need a subset of this supporting metadata and decide not to store every piece of data provided. For example, the standard Twitter metadata includes the numeric character position of hashtags in a tweet message. You may decide that you do not need this information, and therefore can omit those details from your database schema. 

To filter out such data means simply that you do not have a field in your database to store it, and when parsing the tweet payload you simply ignore the attribute.

-----------
*How can I protect myself from later realizing that there are key metadata that I originally did not store?* 
Note that there is the option to store the entire activity payload in its own text field. This option should be considered carefully since it can essentially double database size. 

More appropriate for finite sets of activities, such as those generated by a Historical PowerTrack job. As opposed to a real-time system when the amount of stored activities is continually growing.

[Example of tweeting in the rain blog data, and wanting to revisit agency follower counts during and after flood events.]

and building capabilities to work with these contents are not trivial. 

If you are at all concerned about needing to analyze metadata not included in your schema, a best practice is to store the original JSON objects for future analysis or re-processing. These can be stored in a NoSQL-type system or simply as flatfiles.

-----------

###Storing Metadata Arrays
Twitter data is dynamic in nature, and includes several types of metadata that are in arrays of variable length. For example, tweets can consist of multiple hashtags, urls, user mentions, and soon via the firehose, multiple photographs.  JSON readily supports arrays of data, while schemas are static in nature.  The concept of having a database field 'grow' to store dynamic array lengths of data does not exist.  To manage this strutural incongruity, there are three basic schema design strategies:

1) Store delimited lists in a single field.

Pros: Most compact schema design, simple queries to select data (no joins).
Cons: software inserting data needs to create the delimited list of metadata. 
      software selecting data from database needs to have special logic to 'unpack' the delimited lists. 

2) Create a set of fields to hold multiple instances.
For example, hashtags could be stored in a set of fields such as hashtag_1, hashtag_2, hashtag_3, hashtag_4. For short-content sources like Twitter, limited to 140 characters, there is a good chance that there is a reasonable upper-limit on the number of items you need to support.

Pros: (can't think of any!)
Cons: uglier queries, sparse contents (lots of empty fields), hardcodes the number of intenties you can process at the schema level. 

3) Create separate tables to hold multiple instances.
This method relies on have separate tables to store multiple items. For example you could have 'hashtags' and 'mentions' tables that are tied to your 'activity' table by the activity ID. This design provides for the dynamic and '3-d' nature of JSON objects.
Pros: Efficiently models the dynamic nature of JSON objects where there is a variable list of metadata attributes. 
Cons: (any?)

###Tracking Select Time-series Changes  


###Some Example Schemas

####Generating Schemas with Ruby ActiveRecord 

* This schema mandates that metadata arrays (twitter entities, matching rules, etc) be flattened into a delimited field. An alternative is to have associated tables (such as a hashtag table). How do you guys store metadata arrays?


```
ActiveRecord::Schema.define(:version => 20140517212018) do

  create_table "activities", :force => true do |t|
    t.string 'native_id'
    t.datetime 'posted_at'
    t.text 'content'
    t.string 'body'
    t.integer 'actor_id'     #--> actor table id
    t.string 'verb'
    t.integer 'repost_of'
    t.string 'lang'              
    t.string 'pub_lang'   #--> twitter_lang 

    #These are flattened arrays, comma delimited (?)
    t.string 'hash_tags'
    t.string 'mentions'
    t.text 'urls'               #Expanded URLs when available
    t.string 'media'
    t.text 'rule_values'   
    t.text 'rule_tags'        
                            
    #Activity geo details
    t.string 'place'
    t.string 'country_code'
    t.float 'long'
    t.float 'lat'

    #Activities may be coming from different products/publishers
    t.integer 'stream_id' 
    t.string 'publisher'   

    t.datetime 'created_at'
    t.datetime 'updated_at'
  end

create_table "actors", :force => true do |t|
    t.string 'native_id'
    t.string 'bio'
    t.integer 'followers_count'
    t.integer 'friends_count'
    t.integer 'statuses_count'
    t.integer 'klout_score'
    t.text 'topics'   #klout topics   #flattened array
    t.string 'lang'
    t.string 'time_zone'
    t.integer 'utc_offset'
    t.datetime 'posted_at'

    #Actor geo metadata
    t.string 'location'
    #These really are flattened arrays, but currently will only have one item.
    t.string 'profile_geo_name'
    t.float 'profile_geo_long'
    t.float 'profile_geo_lat'
    t.string 'profile_geo_country_code'
    t.string 'profile_geo_region'
    t.string 'profile_geo_subregion'
    t.string 'profile_geo_locality'
    
    t.datetime 'created_at'
    t.datetime 'updated_at'
  end
```


####Generating Schemas with MySQL Scripts 


```
DROP TABLE IF EXISTS activities;
CREATE TABLE `activities` (
    `act_table_id` INT(16) NOT NULL AUTO_INCREMENT                      # arb integer
    , `activityId` BIGINT UNSIGNED NOT NULL DEFAULT 0                   # snowflake 
    , `powertrack_rule` TEXT NOT NULL DEFAULT ''                        # Search query that returned this data
    , `act_created_at` DATETIME NOT NULL DEFAULT '0000-00-00 00:00:00'  # timestamp of table load 
    , `postedTime` DATETIME NOT NULL DEFAULT '0000-00-00 00:00:00'      # activity postedTime
    , `verb` CHAR(16) DEFAULT NULL                                      # post/share/compliance 
    , `actor_id` INT(16) UNSIGNED NOT NULL DEFAULT 0                    # numerical id  
    , `body` TEXT DEFAULT NULL                                          # activity body text (whitespace padded) 
    , `twitter_lang` CHAR(8) DEFAULT NULL                               # tweet body lang (tw) 
    , `gnip_lang` CHAR(8) DEFAULT NULL                                  # tweet body lang (enrichment)
    , `link` CHAR(255) DEFAULT NULL                                     # www activity location url 
    , `generator_displayName` CHAR(255) DEFAULT NULL                    # service / platform
    , `geo_lat` DECIMAL(11,8) DEFAULT NULL                              # geo-tagged coord (points only)
    , `geo_lon` DECIMAL(11,8) DEFAULT NULL                              # (slightly absurd scale & precision)
    , `entities_symbol1` CHAR(255) DEFAULT NULL                         # symbol (e.g. cashtag) 
    , `entities_symbol2` CHAR(255) DEFAULT NULL                         # symbol (e.g. cashtag)
    , `entities_symbol3` CHAR(255) DEFAULT NULL                         # symbol (e.g. cashtag)
    , `entities_symbol4` CHAR(255) DEFAULT NULL                         # symbol (e.g. cashtag)
    , `entities_symbol5` CHAR(255) DEFAULT NULL                         # symbol (e.g. cashtag)
    , `entities_mention1_id` INT(16) UNSIGNED DEFAULT NULL                       # mention (user id) 
    , `entities_mention1_name` CHAR(20) DEFAULT NULL                    # mention (display name) 
    , `entities_mention2_id` INT(16) UNSIGNED DEFAULT NULL                       # mention (user id) 
    , `entities_mention2_name` CHAR(20) DEFAULT NULL                    # mention (display name) 
    , `entities_mention3_id` INT(16) UNSIGNED DEFAULT NULL                       # mention (user id) 
    , `entities_mention3_name` CHAR(20) DEFAULT NULL                    # mention (display name) 
    , `entities_mention4_id` INT(16) UNSIGNED DEFAULT NULL                       # mention (user id) 
    , `entities_mention4_name` CHAR(20) DEFAULT NULL                    # mention (display name) 
    , `entities_mention5_id` INT(16) UNSIGNED DEFAULT NULL                       # mention (user id) 
    , `entities_mention5_name` CHAR(20) DEFAULT NULL                    # mention (display name) 
    , `entities_url1_short` CHAR(64) DEFAULT NULL                       # url (t.co)
    , `entities_url1_expanded` TEXT DEFAULT NULL                   # url (unwound)
    , `entities_url2_short` CHAR(64) DEFAULT NULL                       # url (t.co)
    , `entities_url2_expanded` TEXT DEFAULT NULL                   # url (unwound)
    , `entities_url3_short` CHAR(64) DEFAULT NULL                       # url (t.co)
    , `entities_url3_expanded` TEXT DEFAULT NULL                   # url (unwound)
    , `entities_url4_short` CHAR(64) DEFAULT NULL                       # url (t.co)
    , `entities_url4_expanded` TEXT DEFAULT NULL                   # url (unwound)
    , `entities_url5_short` CHAR(64) DEFAULT NULL                       # url (t.co)
    , `entities_url5_expanded` TEXT DEFAULT NULL                   # url (unwound)
    , `entities_media1_id` BIGINT DEFAULT NULL                         # media (photo) id
    , `entities_media1_url` TEXT DEFAULT NULL                      # media (photo) expanded url
    , `entities_media2_id` BIGINT DEFAULT NULL                         # media (photo) id
    , `entities_media2_url` TEXT DEFAULT NULL                      # media (photo) expanded url
    , `entities_media3_id` BIGINT DEFAULT NULL                         # media (photo) id
    , `entities_media3_url` TEXT DEFAULT NULL                      # media (photo) expanded url
    , `entities_media4_id` BIGINT DEFAULT NULL                         # media (photo) id
    , `entities_media4_url` TEXT DEFAULT NULL                      # media (photo) expanded url
    , `entities_media5_id` BIGINT DEFAULT NULL                         # media (photo) id
    , `entities_media5_url` TEXT DEFAULT NULL                      # media (photo) expanded url
    , PRIMARY KEY (`activityId`)
) 
ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci
;
```


